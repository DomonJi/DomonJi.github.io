<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[如何更优雅地使用 Rxjs]]></title>
      <url>%2Fhow-to-use-rxjs-elegantly%2F</url>
      <content type="text"><![CDATA[我们的 DCE 项目使用 Rxjs 作为数据流动的框架，这种响应式的编程思想很适合 DCE 这样的数据流动复杂的应用，却也带来不小的使用门槛。近日，在审阅我们代码的过程中，我发现了很多不规范甚至是不正确的 Rxjs 使用方法，不仅造成了代码丑陋，冗余，甚至会引起意想不到的bug。 我找了几处经典的案例，看看我们如何更优雅地使用 Rxjs 。 案例案例 1我们先来看一处简单的案例12345678userInfo$.subscribe(v =&gt; &#123; settingApi.getAccessKeys(v.name) .then(accessKeys =&gt; &#123; this.accessKeys = accessKeys; this.updateRemoteBuildCommand(this.rules.remoteBuildConfig); this.updateWebhook(); &#125;);&#125;); 这样的代码在项目中很常见，乍一看似乎没有什么问题，但我认为暗藏玄机： Promise 和 Observable 混用，造成代码可读性低。 在 subscribe 中发起请求之后修改本地数据，此处操作相当于 mergeMap，这样一来就会有一个问题，先发出的请求由于网络延迟返回的比后发出的请求返回的还慢，这样子当先发出的请求到达了之后就用旧的数据把新的数据覆盖，造成不可预期的后果。 经过一番重构，我认为这样子会更加优雅：12345678userInfo$ .pluck('name') .switchMap(settingApi.getAccessKeys) .subscribe(accessKeys =&gt; &#123; this.accessKeys = accessKeys; this.updateRemoteBuildCommand(this.rules.remoteBuildConfig); this.updateWebhook(); &#125;); 使用 switchMap 便解决了上述两个问题。关于 ‘switchMap’ 以及各种 map的区别，请看：mergeMapconcatMapswitchMapexhaustMap 这段代码第三行等价于：1.switchMap(name =&gt; Rx.Observable.fromPromise(settingApi.getAccessKeys(name))) 案例 2123456789101112131415161718192021222324252627appApi.create(params) .then(res =&gt; &#123; switch (res.status) &#123; case 201: // 应用详情的数据是从列表数据中获取的, // 而列表数据依赖整个 Stream 系统, // 因此这里只需要等待列表更新然后再跳转即可。 hub.hub$$.next('app'); appsVm$$.subscribe(apps =&gt; &#123; if (_.find(apps, &#123; name: this.appName &#125;)) &#123; this.$router.push(&#123; name: 'AppDetail', params: &#123; name: this.appName &#125; &#125;); &#125; &#125;); break; case 207: res.data.Errors.forEach(err =&gt; &#123; new Noty(&#123; text: err, type: 'error', &#125;).show(); &#125;); break; default: &#125; &#125;); 此处代码来自 new-from-registry.js 可以看到，这段代码的目的是发起一个创建应用的请求，成功后去订阅 appsVm$$ 等到应用列表中确实存在新建的应用便跳转到应用详情页中。这段代码有两个问题： Promise 和 Observable 混用，造成代码可读性低。 在请求成功后订阅了 appsVm$$ ，却并没有任何地方去取消这个订阅，也就导致了一个非常严重的bug，即创建应用后，在容器组列表中点击刷新按钮也会跳转到应用详情页中，因为执行了 hub.hub$$.next(&#39;pod&#39;)。 经过重构一番之后，我认为合理并且优雅的代码应该如下 123456789101112131415161718const [succeed$, error$] = Rx.Observable.fromPromise(appApi.create(params)) .partition(res =&gt; res.status === 201); succeed$.do(() =&gt; hub.hub$$.next('app')) .concatMapTo(appsVm$$) .first(apps =&gt; _.some(apps, app =&gt; app.name === this.appName)) .subscribe(() =&gt; &#123; this.$router.push(&#123; name: 'AppDetail', params: &#123; name: this.appName &#125; &#125;); &#125;); error$.subscribe(res =&gt; &#123; res.data.Errors.forEach(err =&gt; &#123; new Noty(&#123; text: err, type: 'error', &#125;).show(); &#125;); &#125;); 将 Promise 转化为 Observable ，通过 partition 将其分为成功和错误的两条流。我们关注成功的这个 Observable，在 do 中做副作用，之后将其映射为 appsVm$$，取第一个符合条件的数据对其订阅。这边 first 操作符会在得到第一个符合的数据之后立刻发出 complete，订阅也随即停止。 关于 partition： partition 案例 312345678910111213141516171819202122232425262728293031networkApi.create(params, params.nodeAddress, tenant, userName) .then(res =&gt; &#123; const networksNumber = this.networks.all.length; const interval = setInterval(() =&gt; &#123; hub.hub$$.next('network'); &#125;, 2000); const temp_ = networksVm$$.subscribe(networks =&gt; &#123; if (networks.all.length &gt; networksNumber) &#123; new Noty(&#123; text: '网络创建成功。', type: 'success', &#125;).show(); // 把参数恢复到默认 this.data = _.clone(DEFAULT); this.isShow = false; this.creating = false; temp_.unsubscribe(); clearInterval(interval); this.$router.push(&#123; path: `/network-detail/$&#123;res.Id&#125;`, &#125;); &#125; &#125;); &#125;) .catch(rej =&gt; &#123; this.creating = false; new Noty(&#123; text: `网络 $&#123;this.data.name&#125; 创建失败，请重试！&lt;br&gt;错误信息：$&#123;rej.data.message&#125;`, type: 'error', &#125;).show(); &#125;; 这段代码来自 create-network.js 它的目的是请求成功后不断地去轮询，直到网络真的创建成功，再跳转路由。这段代码同时存在以下几个问题： Promise 和 Observable 混用，造成代码可读性低。 同时还有 setInterval混入。 自己手动的取消 Interval 和取消订阅，造成了不必要的麻烦和代码冗余。 这段逻辑使用Rxjs重构的难点便是在这个轮询上。于是考虑使用 Observable.interval 来构造一个定时产生数据的 Observable。1234567Rx.Observable .fromPromise(networkApi.create(params, params.nodeAddress, tenant, userName)) .concatMap(res =&gt; Rx.Observable.interval(1000).mapTo(res)) .do(() =&gt; hub.hub$$.next('network')) .combineLatest(networksVm$$) .first(([res, networks]) =&gt; _.some(networks.all, network =&gt; network.id === res.Id)) .subscribe(this.onSuccess, this.onError); 将 Promise 得到的结果映射为每隔1秒发送一遍的 Observable，在 do中做 hub.hub$$.next(&#39;network&#39;)，同时结合 networksVm$$，订阅第一个符合条件（也就是网络成功被创建）的数据，展示创建成功的信息，在异常的时候调用onError展示错误信息。这边把成功和失败的信息展示抽离出来成为单独的方法。 案例 412345678910111213141516171819202122232425262728293031323334nodeApi.removeK8s(node).then(res =&gt; &#123; nodeApi.down(node) .then(() =&gt; &#123; const timer = setInterval(() =&gt; &#123; const promise = nodeApi.detail(node.id) .then(res =&gt; &#123; if (res.Status.State === 'down') &#123; clearInterval(timer); return nodeApi.remove(node) .then(() =&gt; &#123; hub.hub$$.next('all'); new Noty(&#123; text: '成功删除主机', type: 'success', &#125;).show(); &#125;); &#125; return false; &#125;); return promise; &#125;, 3 * 1000); &#125;) .catch(rej =&gt; &#123; new Noty(&#123; text: `删除主机失败，错误信息: $&#123;rej.data.message&#125;`, type: 'error', &#125;).show(); &#125;);&#125;).catch(rej =&gt; &#123; new Noty(&#123; text: `删除主机失败，错误信息: $&#123;rej.data.message&#125;`, type: 'error', &#125;).show();&#125;); 这段代码已经是惨不忍睹，嵌套了4层then加一层setInterval。它的目的是，发送两个请求之后去轮询主机详情，直到状态为 down 时再发起请求移除这个主机节点，之后提示成功或者失败的消息。 首先我们可以用 Promise.all 把连续的两个 Promise合并再转换为每隔3秒轮询一次的 Observable取第一个状态为 down 的数据，调用api移除这个节点，然后通知 hub，最后订阅这个流，输出成功和错误的提示消息。 重构后的代码如下。12345678910Observable.fromPromise(Promise.all([ nodeApi.removeK8s(node), nodeApi.down(node),])) .concatMapTo(Observable.interval(3000)) .switchMap(() =&gt; nodeApi.detail(node.id)) .first(res =&gt; res.Status.State === 'down') .switchMap(() =&gt; nodeApi.remove(node)) .do(() =&gt; hub.hub$$.next('all')) .subscribe(successNoty, errorNoty); 案例 51234567891011121314151617socket$$.subscribe(job =&gt; &#123; // 因为 job 推送来的数据并不是 build 的数据 // 所以我还得根据 jobId 查到具体的 build 的数据 // 索性每次拿到 job 就重新拿列表 if (!job) return; const tempName = `$&#123;this.repo.namespace.name&#125;/$&#123;this.repo.name&#125;`; if (job.entity.name === tempName) &#123; const getRepoBuildsPromise = this.getRepoBuilds(); if (job.state.type === 'Succeed') &#123; getRepoBuildsPromise.then(() =&gt; &#123; if (this.builds.length) &#123; this.updateTagList(this.builds[0].ImageTag); &#125; &#125;); &#125; &#125;&#125;); 这段代码也是我们的项目中很常见的，把所有的逻辑都放在 subscribe 中，这样就让 subscribe 中逻辑很臃肿。 我们先来看一下这段代码的逻辑：订阅了socket$$，当 job.entity.name === tempName 时去调用 this.getRepoBuilds这个函数，这个函数里发起了一个请求之后修改了本地数据（实际上这样的函数很不纯，我觉得不应该在这个函数里修改本地数据），并返回一个 Promise，如果 job.state.type === &#39;Succeed&#39;，那么在这个 Promise resolve 之后去修改本地数据。 这段代码的难点就在于如何等到这个 Promise resolve 之后再去修改本地数据。实际上Rx是很强大的，你能想到的任何对流的操作几乎都有对应的方法，比如这个例子，我们就可以使用 delayWhen这个操作符。它接收的是一个方法。 重构之后的代码如下：123456789socket$$ .filter(job =&gt; job &amp;&amp; job.entity.name === tempName) .delayWhen(this.getRepoBuilds) .filter(job =&gt; job.state.type === 'Succeed') .subscribe(() =&gt; &#123; if (this.builds.length) &#123; this.updateTagList(this.builds[0].ImageTag); &#125; &#125;); 上面第三行代码等价于：1.delayWhen(() =&gt; Rx.Observable.fromPromise(this.getRepoBuilds())) 关于 delayWhen： delayWhen 还有一点更重要的我们DCE代码中很多地方，比如创建镜像，都会给某个按钮点击事件绑定一个方法，在这个方法里面去subscribe一个流，然后去做一些操作，我觉得这样是不合理的，因为如果没有对点击加以限制，用户不断的点击，就会不断的去subcribe，会引起一些不可预料的结果，甚至引起性能问题，尤其是在一些点击之后需要轮询操作的地方。实际上我们应该在点击的时候做 next 操作而不是 subcribe操作。 所以上面所有案例的重构并没有解决根本的问题！我认为所有流的订阅都应该放在组件初始化的时候，组件的方法只对流做 next 操作和修改本地数据。 比如对于一个点击事件，更合理的做法是利用 vue-rx的一个指令 v-stream:click 把点击事件转换成一个流，与你需要订阅的流合并，在组件mounted的时候去subcribe这个点击事件的流。举例如下： 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;button v-stream:click="&#123; subject: click$, data: someData &#125;"&gt;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import someApi from '...somePath'import someStream$$ from '...somePath'export default &#123; data() &#123; return &#123; someData: 'someData', &#125;; &#125;, subscriptions() &#123; this.click$ = new Rx.Subject(); &#125;, mounted() &#123; this.$subscribeTo( this.click$.switchMap(someApi.someMethod) .concatMapTo(Rx.Observable.interval(1000)) .combineLatest(someStream$$) .first(/** some logic */), onNext, onError, OnComplete, ); &#125;,&#125;&lt;/script&gt; 值得注意的是：vue-rx 中提供了一个 $subscribeTo方法，可以自动的在组件销毁时 unsubscribe 所有的订阅，很多情况下可以代替 subscribe方法。 于是我们可以给 Observable 的原型链上添加一个方法，便于我们链式调用。 123456// 给 Observable 添加的方法// 在 Vue 实例中使用 observable.$subscribeTo(this, onNext, onError, onComplete)// 等价于使用 this.$subscribeTo(observable, onNext, onError, onComplete)Rx.Observable.prototype.$subscribeTo = function $subscribeTo(_vm, onNext, onError, onComplete) &#123; Vue.prototype.$subscribeTo.call(_vm, this, onNext, onError, onComplete);&#125; 上述 mounted 函数便可更加简洁：1234567mounted() &#123; this.click$.switchMap(someApi.someMethod) .concatMapTo(Rx.Observable.interval(1000)) .combineLatest(someStream$$) .first(/** some logic */) .$subscribeTo(this, onNext, onError, onComplete);&#125;, 现在我们项目中对 vue-rx 的使用还只停留在给vue实例上加一个subscriptions对象，实际上 vue-rx还提供了很多很便利的方法和指令：$watchAsObservable可以观察一个data数据产生一个流。$createObservableMethod可以创建一个流，在一个方法每次调用的时候发出它的参数。v-stream:click可以从一个点击事件上创建一个流，每次点击可以发出你想要发出的数据。还有$eventToObservable、$fromDomEvent等，大家可以参阅 vue-rx 文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Rxjs 数据流实践]]></title>
      <url>%2Frxjs-dataflow-in-action%2F</url>
      <content type="text"><![CDATA[遇到的困难目前公司的核心项目DCE(DaoCloud Enterprise)是一个非常复杂的SPA，它的复杂性主要体现在数据和交互逻辑两方面上。在数据方面，DCE管理着相当多的数据。在交互逻辑方面，DCE中的每一个操作几乎都是牵一发而动全身。但是交互逻辑的复杂归根结底是表现为数据的复杂，因为每一次交互，本质上都是在处理数据。为了保证数据的正确性，原来使用angularjs写的DCE中有很多数据处理、检测数据变化的代码，结果导致应用非常的卡顿。 复杂数据SPA应用的难点数据来源多DCE的数据主要有以下几个来源： 后端和Docker的API API是数据的主要来源，应用、服务、容器、存储、租户等信息都是通过API获取的。 Docker API 所使用的 streamstream 也是一个通信协议。Docker使用这个协议来通知容器状态的变化。 后端的Socker后端通过socket来通知应用等数据的状态的变化。 localStorage保存用户信息，租户信息等。 数据来源多导致了两个问题： 复用处理数据的逻辑比较困难：比如容器列表这个数据。获取的时候我们需要一段代码来格式化容器列表。但是容器列表之后还会更新，由于更新的逻辑和获取的逻辑不一样，所以就很难再复用之前所使用的代码。 2.获取数据的接口形式不统一： 如今我们调用API时，都会返回一个Promise。但是不是所有的数据来源都能转换成Promise，比如Socket事件，结果就是在获取数据的时候，要先调用API，单后再监听socket事件。结果就是代码的冗余。 数据复杂DCE数据的复杂还体现在三个方面： 后端获取的数据不能直接展示，要经过一系列复杂逻辑的格式化 其中部分格式化逻辑还包括发送请求。 数据之间还存在着复杂的依赖关系。 数据更新困难缓存是个很好的想法，但是在一个对数据的实时性要求非常高的应用中，缓存很难做的足够好。DCE中几乎所有数据都是会被全局使用到的。比如郭应用列表的数据，不仅要在应用列表中显示，也可能在侧边栏统计应用数量的地方要用到。所以说如果一处数据更新了，另一处没有更新，那就很尴尬了。还有就是数据的依赖关系，如果被依赖的数据改变了，此时也要更新依赖的缓存数据。但是实际上很多时候数据的依赖树太深了，有些依赖关系还不是很明显，结果就会忘记更新缓存。 结论前端开发两大噩梦：状态管理和异步操作，同时以上三个难点也是传统的flux架构难以胜任的原因。Rxjs在这个时候就能很轻而易举的解决这两大困难。 DCE 的 Rxjs 架构图 alpha 为应用所需的顶层数据源，如版本信息，用户信息以及license等，需要这些数据才能进行下一步。socket 为应用与后端数据实时通信的接口，当后端数据有更新时，通过 socket 发送消息给 hub，通知应用更新。hub 为整个应用最主要的 observable ，是数据的分发中心，当收到socket的消息时，会及时的通知右侧底层数据源调用相应的接口获取最新的数据，而右侧规模较大的数据则由这些底层数据源 combinelatest 拼接而成，形成一颗单向流动的数据树。 Rxjs解决的困难 统一了异步和同步的逻辑。解决异步问题。 数据推送的机制把拉取的操作变成了推送的操作。解决更新问题。 BehaviorSubject 可以缓存数据。解决了状态管理的问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vuejs 踩坑及经验总结]]></title>
      <url>%2Fvue-issues-summarize%2F</url>
      <content type="text"><![CDATA[趟坑总结问题描述在使用 v-for repeat 组件时控制台会出现警告： 解决方法在组件标签上使用 v-for ： 加 :key 使用 template 标签包裹该组件，再在 template 标签 上使用 v-for。 趟坑总结问题描述在 Vue data 属性中定义的变量名如果以 “_” 开头，就不能正确的赋值和渲染 问题原因https://github.com/vuejs/vue/issues/2098 解决方法变量名不要以 “_” 开头趟坑总结问题描述在我们的前端组件库 dao-option 组件中 中使用 :key 时，如果 v-for 枚举的值是 Object，但是 :key 中的值是简单类型时，dao-options 选出来的值并不在 dao-select 原本储存的 options 中。 问题原因在组件中使用 :key 时，如果 v-for 枚举的值是 Object，但是 :key 中的值是简单类型时，当 Object 地址改变，:key 中解析值没变时，组件会被复用，并不会被销毁。例如： dao-style 的 dao-select 中 dao-option 因为上述的描述导致组件没被销毁，最终 dao-options 选出来的值不在 dao-select 原本储存的 options 中。 解决方法:key 绑定复杂类型趟坑总结问题描述在 Vue Router 中定义路由为 a/:id 形式时，从 a/1 跳转到 a/2 时，不会触发 component 的 created 等方法。 解决方法1.&lt;router-view :key=&quot;$route.path&quot;&gt;&lt;/router-view&gt; 在 component 中监听 $route.path 的变化，手动触发 created 内的方法。P.S. 可以参照 router-link 中的 响应路由参数的变化 趟坑总结问题描述不能直接 watch subscriptions 中的变量，回调不会执行。 解决方法要先在 data 中注册该变量]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017阿里前端暑假实习面试经历]]></title>
      <url>%2Fali-frontend-trainee-interview%2F</url>
      <content type="text"><![CDATA[3月6日上午 10:27 25分钟 一面 自我介绍 主要就讲了自己的学校，学过的课程，给学校做过的项目啊，自己做过的项目。 闭包 是指一个函数能记住并访问它所在的作用域（相关内容具体可以看《你不知道的JavaScript》），闭包产生的原因是函数作用域。 闭包有哪些优缺点 我一开口讲内存泄漏问题，面试官就打断并提问，如果同时有大量请求，每次请求都会调用一个settimeout，此时造成大量闭包内存如何解决，我当时没回答上来…… 解释一下尾递归 尾递归指的是函数的最后一次调用是完全调用自身的函数。V8引擎会对尾递归调用作相应的优化。 V8引擎对尾递归调用有什么样的优化 不需要保存调用栈信息，只需要保存调用记录。 遍历数组有哪些方法 forEach,map,reduce,filter 其实还有some,every,reduceRight我当时没想起来 有哪些 HTTP Methods GET,POST,PUT,DELETE,HEAD,PATCH,OPTION 面试官说还有TRACE，我开始慌了😂 CSS垂直居中的方法 这个问题可以看《CSS揭秘》 绝对定位方法、基于视口单位方法、flexbox方法。 浏览器事件循环 浏览器会把异步操作放入事件队列中，主线程调用栈全部弹空之后会去检查事件队列并把事件队列中需要执行的事件放入主线程调用，如此循环。 Vuejs的特点 组件化, 双向数据绑定, defineProperties数据劫持,Observer and Watcher, 渐进式, Virtual Dom. XSS CSRF 我就讲了他们的原理，这两个知识点网上应该有很多介绍。 提问环节 阿里这样的大公司会偏向于使用开源的框架还是自己造的轮子？ 结果感觉自己回答的还比较轻松，除了上面提到的几个没回答上来的问题。结果还是挂了，学长告知是阿里一个P7级别的主管按照社招标准来面试我的，运气也是有点差。希望再接再厉，查漏补缺，吸取经验教训，为以后的面试做准备吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
